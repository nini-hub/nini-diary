---
title: 面试题-从输入 url 到页面呈现的过程
date: '2022-04-20'
tags: ["面试题"]
published: true
---
URL 解析：
判断输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作
接着发起真正的 URL 请求
如果浏览器本地缓存了这个资源，则会直接将数据转发给浏览器进程，如果没有缓存，则会查询 DNS 解析域名
首先先找浏览器有没有 DNS 缓存（之前有访问记录），如果有则 返回 ip
如果没有，则寻找本地的 host 文件，看看有没有域名记录，如果有则返回 ip
如果本地 host 没有则直接向 DNS 服务器请求，如果还是没有，继续向上 DNS 服务器请求，直至返回
浏览器拿到 ip 后，再向服务器发送 http 请求之前，先要和服务器建立 tcp 连接，其实就是三次握手
第一次握手：客户端发送 SYN，数据包给服务端
第二次握手：服务端收到客户端的数据包，返回 SYN，ACK 数据包给客户端
第三次握手：客户端收到服务端的数据包，发送 ACK ，数据包给服务端
连接建立成功后，就可以发送 http 请求到腐恶去请求数据了
客户端向服务器发起 http 请求的时候，会有一些请求信息，请求信息包含三个部分
1. 请求方法，uri 协议、版本，2. 请求头，3. 请求正文
请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来是请求正文
然后后端从在固定的端口接收到 tcp 报文开始，他会对 tcp 连接进行处理，对 http 协议进行解析，并按照报文格式进一步封装成 http request 对象
一般大型的网站会将你的请求到反向代理的服务器中
因为网站访问量非常大，网站越来越慢，一台服务器已经不够用了
于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台服务器处理
此时客户端不是直接通过 htttp 协议访问某网站应用服务器
而是先请求到 nginx，nginx 再请求应用服务器，然后再讲结果返回给客户端
这里 nginx 的作用的反向代理服务器
同时也带来一个好处，其中万一一台服务器挂了，只要还有其他服务器正常运行，就不会影响用户使用
通过 nginx 的反向代理，我们到达了 web 服务器，服务端处理请求，访问数据库，然后将处理结果返回
也就是返回一个 http 响应
http 响应 与 http 请求相似，http 响应也是由三个部分构成，分别是：状态行，响应头，响应正文
浏览器接收到来自服务器的响应资源后，如果响应资源进行了压缩，需要进行解压
然后对相应资源做缓存
接下来就对资源进行解析
1 html 通过 html 解析器解析输出 DOM 树
2 css 样式通过 css 解析器解析输出 css 规则
3 结合 dom 树和 css 规则，计算出 DOM 树中每个节点的具体样式，生成渲染树
4 浏览器根据渲染树开始布局和绘制，会触发回流和重绘
5 构建图层数，显示页面 

浏览器在解析 html 文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的 CSS、iconfont 等，请求过程是异步的，并不会影响 html 文档进行加载。

解析过程中，浏览器首先会解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念：reflow（回流）和 repain（重绘）。

DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 relow; 当盒模型的位置，大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为 repain。

页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。

当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我明平时的代码中，js 是放在 html 文档末尾的。

**三次握手为什么是三次不是四次？**
为什么是 3 次？：避免历史连接，确认客户端发来的请求是这次通信的人。
为什么不是 4 次？：3 次够了第四次浪费
**为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**
这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。

**DNS 负载均衡**
不知道你们有没有注意这样一件事，你访问 http://baidu.com 的时候，每次响应的并非是同一个服务器（IP 地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大才能支撑这样大量的访问呢？DNS 可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是 DNS 负载均衡

**若协议是 https 则会做加密**
要先申请 CA 证书，并安装在服务器上（一个文件，配置 nginx 支持监听 443 端口开启 ssl 并设置证书路径）

在 **应用层** 中，将 DNS 解析成 IP，发送 http 请求；
建立 **传输层** 中的 tcp/ip 协议，通过 tcp/ip 协议建立可靠连接；
再通过 **网络层** 的 ip 选址
在 **数据链路层** 封装成对应的 帧
在 **物理层** 中进行传输

### 构建请求的过程
1. DNS 解析：找到目标服务器（通过 ip 的方式寻址）
浏览器缓存 =》系统缓存（host）=》路由器缓存 =》运营商缓存（联通，电信。..) =》域名服务器
2. 在应用层封装 http 请求报文；（报文）
    > *传输层需要的数据：2 封装的报文 + tcp 头部*；
    > 在传输层中传输协议最常用的 UDP，TCP
    > UDP：无状态；TCP：建立可靠链接
3. 在传输层建立 tcp 连接；（数据段）
    + 在网络层：为了确保数据的可靠传输；（帧）
    > 从应用层走到网络层就是加各种头部，由 报文 =》帧
    + 物理层：转化为二进制比特流
    > 网络层，数据链路层，物理层不用关心

### 网络传输的过程
建立物理设备的连接 =》去做数据的传输

### 浏览器渲染过程
#### 解析 html 的过程
1. 解码：转为 unicode 的过程
2. 分词：把字节流 =》短语
3. html 解析：构建节点的过程
4. 建树：构建 dom 树
5. 解析：css
render tree renderLayerTree
6. 解析 js
动态修改 dom 树
7. 回流和重绘
